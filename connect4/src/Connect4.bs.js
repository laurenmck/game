// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var CS17SetupGame$Connect4 = require("./CS17SetupGame.bs.js");

function initialBoard(n, m) {
  var initialRow = function (n) {
    if (n !== 0) {
      return {
              hd: 0,
              tl: initialRow(CS17SetupGame$Connect4.$neg(n, 1))
            };
    } else {
      return /* [] */0;
    }
  };
  if (m !== 0) {
    return {
            hd: initialRow(n),
            tl: initialBoard(n, CS17SetupGame$Connect4.$neg(m, 1))
          };
  } else {
    return /* [] */0;
  }
}

var initialState_0 = {
  TAG: /* Ongoing */1,
  _0: /* P1 */0
};

var initialState_1 = initialBoard(5, 7);

var initialState = /* State */{
  _0: initialState_0,
  _1: initialState_1
};

function stringOfPlayer(player) {
  if (player) {
    return "Player 2";
  } else {
    return "Player 1";
  }
}

function stringOfStatus(s) {
  if (typeof s === "number") {
    return "Draw";
  } else if (s.TAG === /* Win */0) {
    return (
            s._0 ? "Player 2" : "Player 1"
          ) + "wins!";
  } else {
    return (
            s._0 ? "Player 2" : "Player 1"
          ) + "'s turn";
  }
}

function transpose(b) {
  if (!b) {
    return /* [] */0;
  }
  var match = b.hd;
  if (match) {
    if (match.tl) {
      return {
              hd: List.map(List.hd, b),
              tl: transpose(List.map(List.tl, b))
            };
    } else {
      return {
              hd: List.flatten(b),
              tl: /* [] */0
            };
    }
  } else {
    return Pervasives.failwith("will not reach this 0-dimensional board case");
  }
}

function printListString(lst) {
  if (lst) {
    return String(lst.hd) + (" " + printListString(lst.tl));
  } else {
    return "";
  }
}

function printBoardString(b) {
  return List.map(printListString, b);
}

function printBoard(b) {
  var printBoardHelper = function (lst) {
    if (lst) {
      return "\n" + (lst.hd + ("\n" + printBoardHelper(lst.tl)));
    } else {
      return "";
    }
  };
  return printBoardHelper(List.map(printListString, List.rev(transpose(b))));
}

function stringOfState(param) {
  return stringOfStatus(param._0) + printBoard(param._1);
}

function stringOfMove(i) {
  return String(i._0);
}

function moveOfString(str) {
  return /* Move */{
          _0: Caml_format.caml_int_of_string(str)
        };
}

function legalMoves(param) {
  var legalMovesHelper = function (_b, _i) {
    while(true) {
      var i = _i;
      var b = _b;
      if (!b) {
        return Pervasives.failwith("will not reach this legalMovesHelper case");
      }
      var match = b.hd;
      if (!match) {
        if (b.tl) {
          return Pervasives.failwith("will not reach this legalMovesHelper case");
        } else {
          return /* [] */0;
        }
      }
      var tl1 = b.tl;
      var tl = match.tl;
      var hd = match.hd;
      if (tl1) {
        if (List.mem(0, {
                hd: hd,
                tl: tl
              })) {
          return {
                  hd: /* Move */{
                    _0: i
                  },
                  tl: legalMovesHelper(tl1, CS17SetupGame$Connect4.$plus(i, 1))
                };
        }
        _i = CS17SetupGame$Connect4.$plus(i, 1);
        _b = tl1;
        continue ;
      }
      if (List.mem(0, {
              hd: hd,
              tl: tl
            })) {
        return {
                hd: /* Move */{
                  _0: i
                },
                tl: /* [] */0
              };
      }
      _b = {
        hd: tl,
        tl: /* [] */0
      };
      continue ;
    };
  };
  return legalMovesHelper(param._1, 1);
}

function gameStatus(param) {
  return param._0;
}

function correctColumn(_b, _i) {
  while(true) {
    var i = _i;
    var b = _b;
    if (!b) {
      return /* [] */0;
    }
    var match = b.hd;
    if (!match) {
      return Pervasives.failwith("will not reach this correctColumn case");
    }
    if (i === 1) {
      return {
              hd: match.hd,
              tl: match.tl
            };
    }
    _i = CS17SetupGame$Connect4.$neg(i, 1);
    _b = b.tl;
    continue ;
  };
}

function replacer(lst, s) {
  if (!lst) {
    return /* [] */0;
  }
  var tl = lst.tl;
  var hd = lst.hd;
  if (hd === 0 && typeof s !== "number" && s.TAG !== /* Win */0) {
    if (s._0) {
      return {
              hd: 2,
              tl: tl
            };
    } else {
      return {
              hd: 1,
              tl: tl
            };
    }
  }
  if (typeof s === "number" || s.TAG === /* Win */0) {
    return {
            hd: hd,
            tl: tl
          };
  } else {
    return {
            hd: hd,
            tl: replacer(tl, s)
          };
  }
}

function drop(b) {
  if (!b) {
    return /* [] */0;
  }
  var tl = b.tl;
  if (tl) {
    return {
            hd: b.hd,
            tl: drop(tl)
          };
  } else {
    return /* [] */0;
  }
}

function updateBoard(b, i, s) {
  var updateBoardHelper = function (b, i, s) {
    if (i !== 0) {
      if (i !== 1) {
        if (i === List.length(b)) {
          return List.append(drop(b), {
                      hd: replacer(correctColumn(b, i), s),
                      tl: /* [] */0
                    });
        } else {
          return {
                  hd: List.hd(b),
                  tl: updateBoardHelper(List.tl(b), CS17SetupGame$Connect4.$neg(i, 1), s)
                };
        }
      } else {
        return {
                hd: replacer(correctColumn(b, i), s),
                tl: List.tl(b)
              };
      }
    } else {
      return Pervasives.failwith("invalid move, not a column");
    }
  };
  return updateBoardHelper(b, i._0, s);
}

function checkForZeroes(_b) {
  while(true) {
    var b = _b;
    if (!b) {
      return false;
    }
    if (List.mem(0, b.hd)) {
      return true;
    }
    _b = b.tl;
    continue ;
  };
}

function oppositePlayer(s) {
  if (Caml_obj.caml_equal(s, {
          TAG: /* Ongoing */1,
          _0: /* P1 */0
        })) {
    return {
            TAG: /* Ongoing */1,
            _0: /* P2 */1
          };
  } else {
    return {
            TAG: /* Ongoing */1,
            _0: /* P1 */0
          };
  }
}

function vertCount4(b) {
  var vertCount4Helper1 = function (b) {
    var vertCount4Helper2 = function (_lst) {
      while(true) {
        var lst = _lst;
        if (!lst) {
          return [
                  false,
                  0
                ];
        }
        var match = lst.tl;
        if (!match) {
          return [
                  false,
                  0
                ];
        }
        var match$1 = match.tl;
        if (!match$1) {
          return [
                  false,
                  0
                ];
        }
        var match$2 = match$1.tl;
        if (!match$2) {
          return [
                  false,
                  0
                ];
        }
        var hd4 = match$2.hd;
        var hd3 = match$1.hd;
        var hd2 = match.hd;
        var hd1 = lst.hd;
        if (hd1 === hd2 && hd2 === hd3 && hd3 === hd4 && hd1 !== 0) {
          return [
                  true,
                  hd1
                ];
        }
        _lst = {
          hd: hd2,
          tl: {
            hd: hd3,
            tl: {
              hd: hd4,
              tl: match$2.tl
            }
          }
        };
        continue ;
      };
    };
    return List.map(vertCount4Helper2, b);
  };
  var match = List.mem([
        true,
        1
      ], vertCount4Helper1(b));
  var match$1 = List.mem([
        true,
        2
      ], vertCount4Helper1(b));
  if (match) {
    if (match$1) {
      return [
              [
                true,
                1
              ],
              [
                true,
                2
              ]
            ];
    } else {
      return [
              [
                true,
                1
              ],
              [
                false,
                2
              ]
            ];
    }
  } else if (match$1) {
    return [
            [
              false,
              1
            ],
            [
              true,
              2
            ]
          ];
  } else {
    return [
            [
              false,
              1
            ],
            [
              false,
              2
            ]
          ];
  }
}

function vertCount3(b) {
  var vertCount3Helper1 = function (b) {
    var vertCount3Helper2 = function (_lst) {
      while(true) {
        var lst = _lst;
        if (!lst) {
          return [
                  false,
                  0
                ];
        }
        var match = lst.tl;
        if (!match) {
          return [
                  false,
                  0
                ];
        }
        var match$1 = match.tl;
        if (!match$1) {
          return [
                  false,
                  0
                ];
        }
        var match$2 = match$1.tl;
        if (!match$2) {
          return [
                  false,
                  0
                ];
        }
        var hd4 = match$2.hd;
        var hd3 = match$1.hd;
        var hd2 = match.hd;
        var hd1 = lst.hd;
        if (hd1 === hd2 && hd2 === hd3 && hd4 === 0 && hd1 !== 0) {
          return [
                  true,
                  hd1
                ];
        }
        _lst = {
          hd: hd2,
          tl: {
            hd: hd3,
            tl: {
              hd: hd4,
              tl: match$2.tl
            }
          }
        };
        continue ;
      };
    };
    return List.map(vertCount3Helper2, b);
  };
  var match = List.mem([
        true,
        1
      ], vertCount3Helper1(b));
  var match$1 = List.mem([
        true,
        2
      ], vertCount3Helper1(b));
  if (match) {
    if (match$1) {
      return [
              [
                true,
                1
              ],
              [
                true,
                2
              ]
            ];
    } else {
      return [
              [
                true,
                1
              ],
              [
                false,
                2
              ]
            ];
    }
  } else if (match$1) {
    return [
            [
              false,
              1
            ],
            [
              true,
              2
            ]
          ];
  } else {
    return [
            [
              false,
              1
            ],
            [
              false,
              2
            ]
          ];
  }
}

function vertCount3Hole2(b) {
  var vertCount3Hole2Helper1 = function (b) {
    var vertCount3Hole2Helper2 = function (_lst) {
      while(true) {
        var lst = _lst;
        if (!lst) {
          return [
                  false,
                  0
                ];
        }
        var match = lst.tl;
        if (!match) {
          return [
                  false,
                  0
                ];
        }
        var match$1 = match.tl;
        if (!match$1) {
          return [
                  false,
                  0
                ];
        }
        var match$2 = match$1.tl;
        if (!match$2) {
          return [
                  false,
                  0
                ];
        }
        var hd4 = match$2.hd;
        var hd3 = match$1.hd;
        var hd2 = match.hd;
        var hd1 = lst.hd;
        if (hd1 === hd3 && hd2 === 0 && hd3 === hd4 && hd1 !== 0) {
          return [
                  true,
                  hd1
                ];
        }
        _lst = {
          hd: hd2,
          tl: {
            hd: hd3,
            tl: {
              hd: hd4,
              tl: match$2.tl
            }
          }
        };
        continue ;
      };
    };
    return List.map(vertCount3Hole2Helper2, b);
  };
  var match = List.mem([
        true,
        1
      ], vertCount3Hole2Helper1(b));
  var match$1 = List.mem([
        true,
        2
      ], vertCount3Hole2Helper1(b));
  if (match) {
    if (match$1) {
      return [
              [
                true,
                1
              ],
              [
                true,
                2
              ]
            ];
    } else {
      return [
              [
                true,
                1
              ],
              [
                false,
                2
              ]
            ];
    }
  } else if (match$1) {
    return [
            [
              false,
              1
            ],
            [
              true,
              2
            ]
          ];
  } else {
    return [
            [
              false,
              1
            ],
            [
              false,
              2
            ]
          ];
  }
}

function vertCount3Hole3(b) {
  var vertCount3Hole3Helper1 = function (b) {
    var vertCount3Hole3Helper2 = function (_lst) {
      while(true) {
        var lst = _lst;
        if (!lst) {
          return [
                  false,
                  0
                ];
        }
        var match = lst.tl;
        if (!match) {
          return [
                  false,
                  0
                ];
        }
        var match$1 = match.tl;
        if (!match$1) {
          return [
                  false,
                  0
                ];
        }
        var match$2 = match$1.tl;
        if (!match$2) {
          return [
                  false,
                  0
                ];
        }
        var hd4 = match$2.hd;
        var hd3 = match$1.hd;
        var hd2 = match.hd;
        var hd1 = lst.hd;
        if (hd1 === hd2 && hd3 === 0 && hd2 === hd4 && hd1 !== 0) {
          return [
                  true,
                  hd1
                ];
        }
        _lst = {
          hd: hd2,
          tl: {
            hd: hd3,
            tl: {
              hd: hd4,
              tl: match$2.tl
            }
          }
        };
        continue ;
      };
    };
    return List.map(vertCount3Hole3Helper2, b);
  };
  var match = List.mem([
        true,
        1
      ], vertCount3Hole3Helper1(b));
  var match$1 = List.mem([
        true,
        2
      ], vertCount3Hole3Helper1(b));
  if (match) {
    if (match$1) {
      return [
              [
                true,
                1
              ],
              [
                true,
                2
              ]
            ];
    } else {
      return [
              [
                true,
                1
              ],
              [
                false,
                2
              ]
            ];
    }
  } else if (match$1) {
    return [
            [
              false,
              1
            ],
            [
              true,
              2
            ]
          ];
  } else {
    return [
            [
              false,
              1
            ],
            [
              false,
              2
            ]
          ];
  }
}

function vertCount2(b) {
  var vertCount2Helper1 = function (b) {
    var vertCount2Helper2 = function (_lst) {
      while(true) {
        var lst = _lst;
        if (!lst) {
          return [
                  false,
                  0
                ];
        }
        var match = lst.tl;
        if (!match) {
          return [
                  false,
                  0
                ];
        }
        var match$1 = match.tl;
        if (!match$1) {
          return [
                  false,
                  0
                ];
        }
        var hd3 = match$1.hd;
        var hd2 = match.hd;
        var hd1 = lst.hd;
        if (hd1 === hd2 && hd3 === 0 && hd1 !== 0) {
          return [
                  true,
                  hd1
                ];
        }
        _lst = {
          hd: hd2,
          tl: {
            hd: hd3,
            tl: match$1.tl
          }
        };
        continue ;
      };
    };
    return List.map(vertCount2Helper2, b);
  };
  var match = List.mem([
        true,
        1
      ], vertCount2Helper1(b));
  var match$1 = List.mem([
        true,
        2
      ], vertCount2Helper1(b));
  if (match) {
    if (match$1) {
      return [
              [
                true,
                1
              ],
              [
                true,
                2
              ]
            ];
    } else {
      return [
              [
                true,
                1
              ],
              [
                false,
                2
              ]
            ];
    }
  } else if (match$1) {
    return [
            [
              false,
              1
            ],
            [
              true,
              2
            ]
          ];
  } else {
    return [
            [
              false,
              1
            ],
            [
              false,
              2
            ]
          ];
  }
}

function horzCount4(b) {
  return vertCount4(transpose(b));
}

function horzCount3(b) {
  return vertCount3(transpose(b));
}

function horzCount2(b) {
  return vertCount2(transpose(b));
}

function diag(l) {
  var intlst = function (i) {
    return {
            hd: i,
            tl: /* [] */0
          };
  };
  var helper = function (nl, ol) {
    var helper2 = function (nl, ohd) {
      if (nl) {
        if (ohd) {
          return {
                  hd: {
                    hd: ohd.hd,
                    tl: nl.hd
                  },
                  tl: helper2(nl.tl, ohd.tl)
                };
        } else {
          return Pervasives.failwith("will not reach this diaghelper2 case");
        }
      } else {
        return List.map(intlst, ohd);
      }
    };
    if (ol) {
      if (nl) {
        return {
                hd: nl.hd,
                tl: helper(helper2(nl.tl, ol.hd), ol.tl)
              };
      } else {
        return Pervasives.failwith("will not reach this diag helper case");
      }
    } else {
      return nl;
    }
  };
  if (l) {
    return helper(List.map(intlst, l.hd), l.tl);
  } else {
    return Pervasives.failwith("will not reach this diag empty board case");
  }
}

function diagCount4Up(b) {
  return vertCount4(diag(b));
}

function diagCount4Down(b) {
  return vertCount4(diag(List.rev(b)));
}

function diagCount3Up(b) {
  return vertCount3(diag(b));
}

function diagCount3Down(b) {
  return vertCount3(diag(List.rev(b)));
}

function diagCount2Up(b) {
  return vertCount2(diag(b));
}

function diagCount2Down(b) {
  return vertCount2(diag(List.rev(b)));
}

function horzCount3Hole2(b) {
  return vertCount3Hole2(transpose(b));
}

function horzCount3Hole3(b) {
  return vertCount3Hole3(transpose(b));
}

function diagCount3UpHole2(b) {
  return vertCount3Hole2(diag(b));
}

function diagCount3DownHole2(b) {
  return vertCount3Hole2(diag(List.rev(b)));
}

function diagCount3UpHole3(b) {
  return vertCount3Hole3(diag(b));
}

function diagCount3DownHole3(b) {
  return vertCount3Hole3(diag(List.rev(b)));
}

function updateStatus(s, m, b) {
  if (typeof s === "number") {
    return /* Draw */0;
  }
  if (s.TAG === /* Win */0) {
    return {
            TAG: /* Win */0,
            _0: s._0
          };
  }
  var match = updateBoard(b, m, s);
  if (!match) {
    return Pervasives.failwith("will not reach this empty updateStatus case");
  }
  var tl = match.tl;
  var hd = match.hd;
  var match$1 = vertCount4({
        hd: hd,
        tl: tl
      });
  var match$2 = match$1[0];
  if (match$2[0]) {
    if (match$2[1] === 1) {
      return {
              TAG: /* Win */0,
              _0: /* P1 */0
            };
    }
    
  } else if (match$2[1] === 1) {
    var match$3 = match$1[1];
    if (!match$3[0]) {
      if (match$3[1] !== 2) {
        return Pervasives.failwith("will not reach this updateStatus case");
      }
      var match$4 = vertCount4(transpose({
                hd: hd,
                tl: tl
              }));
      var match$5 = match$4[0];
      var exit = 0;
      if (match$5[0]) {
        if (match$5[1] === 1) {
          return {
                  TAG: /* Win */0,
                  _0: /* P1 */0
                };
        }
        exit = 2;
      } else if (match$5[1] !== 1) {
        exit = 2;
      } else {
        var match$6 = match$4[1];
        if (match$6[0]) {
          exit = 2;
        } else {
          if (match$6[1] !== 2) {
            return Pervasives.failwith("will not reach this updateStatus case");
          }
          var match$7 = vertCount4(diag({
                    hd: hd,
                    tl: tl
                  }));
          var match$8 = match$7[0];
          var exit$1 = 0;
          if (match$8[0]) {
            if (match$8[1] === 1) {
              return {
                      TAG: /* Win */0,
                      _0: /* P1 */0
                    };
            }
            exit$1 = 3;
          } else if (match$8[1] !== 1) {
            exit$1 = 3;
          } else {
            var match$9 = match$7[1];
            if (match$9[0]) {
              exit$1 = 3;
            } else {
              if (match$9[1] !== 2) {
                return Pervasives.failwith("will not reach this updateStatus case");
              }
              var match$10 = vertCount4(diag(List.rev({
                            hd: hd,
                            tl: tl
                          })));
              var match$11 = match$10[0];
              var exit$2 = 0;
              if (match$11[0]) {
                if (match$11[1] === 1) {
                  return {
                          TAG: /* Win */0,
                          _0: /* P1 */0
                        };
                }
                exit$2 = 4;
              } else if (match$11[1] !== 1) {
                exit$2 = 4;
              } else {
                var match$12 = match$10[1];
                if (!match$12[0]) {
                  if (match$12[1] !== 2) {
                    return Pervasives.failwith("will not reach this updateStatus case");
                  } else if (checkForZeroes({
                          hd: hd,
                          tl: tl
                        })) {
                    return oppositePlayer(s);
                  } else {
                    return /* Draw */0;
                  }
                }
                exit$2 = 4;
              }
              if (exit$2 === 4) {
                var match$13 = match$10[1];
                if (match$13[0] && match$13[1] === 2) {
                  return {
                          TAG: /* Win */0,
                          _0: /* P2 */1
                        };
                } else {
                  return Pervasives.failwith("will not reach this updateStatus case");
                }
              }
              
            }
          }
          if (exit$1 === 3) {
            var match$14 = match$7[1];
            if (match$14[0] && match$14[1] === 2) {
              return {
                      TAG: /* Win */0,
                      _0: /* P2 */1
                    };
            } else {
              return Pervasives.failwith("will not reach this updateStatus case");
            }
          }
          
        }
      }
      if (exit === 2) {
        var match$15 = match$4[1];
        if (match$15[0] && match$15[1] === 2) {
          return {
                  TAG: /* Win */0,
                  _0: /* P2 */1
                };
        } else {
          return Pervasives.failwith("will not reach this updateStatus case");
        }
      }
      
    }
    
  }
  var match$16 = match$1[1];
  if (match$16[0] && match$16[1] === 2) {
    return {
            TAG: /* Win */0,
            _0: /* P2 */1
          };
  } else {
    return Pervasives.failwith("will not reach this updateStatus case");
  }
}

function nextState(param, m) {
  var b = param._1;
  var s = param._0;
  return /* State */{
          _0: updateStatus(s, m, b),
          _1: updateBoard(b, m, s)
        };
}

function howManyPieces(_b) {
  while(true) {
    var b = _b;
    if (!b) {
      return Pervasives.failwith("will not reach this howManyPieces case");
    }
    var match = b.hd;
    if (!match) {
      if (b.tl) {
        return Pervasives.failwith("will not reach this howManyPieces case");
      } else {
        return 0;
      }
    }
    var tl1 = b.tl;
    var tl = match.tl;
    var hd = match.hd;
    if (tl1) {
      return CS17SetupGame$Connect4.$plus(howManyPieces({
                      hd: {
                        hd: hd,
                        tl: tl
                      },
                      tl: /* [] */0
                    }), howManyPieces(tl1));
    }
    if (hd !== 0) {
      return CS17SetupGame$Connect4.$plus(1, howManyPieces({
                      hd: tl,
                      tl: /* [] */0
                    }));
    }
    _b = {
      hd: tl,
      tl: /* [] */0
    };
    continue ;
  };
}

function result2(b) {
  return {
          hd: vertCount2(b),
          tl: {
            hd: vertCount2(transpose(b)),
            tl: {
              hd: vertCount2(diag(b)),
              tl: {
                hd: vertCount2(diag(List.rev(b))),
                tl: /* [] */0
              }
            }
          }
        };
}

function count1Trues2(b) {
  var count1Trues2Helper = function (_lst) {
    while(true) {
      var lst = _lst;
      if (!lst) {
        return 0;
      }
      var match = lst.hd[0];
      var tl = lst.tl;
      if (match[0]) {
        if (match[1] !== 1) {
          return Pervasives.failwith("will not reach this count1Trues2 case");
        } else {
          return CS17SetupGame$Connect4.$plus(1, count1Trues2Helper(tl));
        }
      }
      if (match[1] !== 1) {
        return Pervasives.failwith("will not reach this count1Trues2 case");
      }
      _lst = tl;
      continue ;
    };
  };
  return count1Trues2Helper(result2(b));
}

function count2Trues2(b) {
  var count2Trues2Helper = function (_lst) {
    while(true) {
      var lst = _lst;
      if (!lst) {
        return 0;
      }
      var match = lst.hd[1];
      var tl = lst.tl;
      if (match[0]) {
        if (match[1] !== 2) {
          return Pervasives.failwith("will not reach this count2Trues2 case");
        } else {
          return CS17SetupGame$Connect4.$plus(1, count2Trues2Helper(tl));
        }
      }
      if (match[1] !== 2) {
        return Pervasives.failwith("will not reach this count2Trues2 case");
      }
      _lst = tl;
      continue ;
    };
  };
  return count2Trues2Helper(result2(b));
}

function result3(b) {
  return {
          hd: vertCount3(b),
          tl: {
            hd: vertCount3(transpose(b)),
            tl: {
              hd: vertCount3Hole2(transpose(b)),
              tl: {
                hd: vertCount3Hole3(transpose(b)),
                tl: {
                  hd: vertCount3(diag(b)),
                  tl: {
                    hd: vertCount3(diag(List.rev(b))),
                    tl: {
                      hd: vertCount3Hole2(diag(b)),
                      tl: {
                        hd: vertCount3Hole3(diag(b)),
                        tl: {
                          hd: vertCount3Hole2(diag(List.rev(b))),
                          tl: {
                            hd: vertCount3Hole3(diag(List.rev(b))),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        };
}

function count1Trues3(b) {
  var count1Trues3Helper = function (_lst) {
    while(true) {
      var lst = _lst;
      if (!lst) {
        return 0;
      }
      var match = lst.hd[0];
      var tl = lst.tl;
      if (match[0]) {
        if (match[1] !== 1) {
          return Pervasives.failwith("will not reach this count1Trues3 case");
        } else {
          return CS17SetupGame$Connect4.$plus(1, count1Trues3Helper(tl));
        }
      }
      if (match[1] !== 1) {
        return Pervasives.failwith("will not reach this count1Trues3 case");
      }
      _lst = tl;
      continue ;
    };
  };
  return count1Trues3Helper(result3(b));
}

function count2Trues3(b) {
  var count2Trues3Helper = function (_lst) {
    while(true) {
      var lst = _lst;
      if (!lst) {
        return 0;
      }
      var match = lst.hd[1];
      var tl = lst.tl;
      if (match[0]) {
        if (match[1] !== 2) {
          return Pervasives.failwith("will not reach this count2Trues3 case");
        } else {
          return CS17SetupGame$Connect4.$plus(1, count2Trues3Helper(tl));
        }
      }
      if (match[1] !== 2) {
        return Pervasives.failwith("will not reach this count2Trues3 case");
      }
      _lst = tl;
      continue ;
    };
  };
  return count2Trues3Helper(result3(b));
}

function estimateValue(param) {
  var b = param._1;
  var s = param._0;
  if (typeof s === "number") {
    return 0.0;
  }
  if (s.TAG === /* Win */0) {
    if (s._0) {
      return -100000000000000000000.0;
    } else {
      return 100000000000000000000.0;
    }
  }
  var match = howManyPieces(b);
  switch (match) {
    case 0 :
        return Pervasives.failwith("will not reach this estimateValue case");
    case 1 :
    case 2 :
        return 0.0;
    case 3 :
        var match$1 = count1Trues2(b);
        var match$2 = count2Trues2(b);
        switch (match$1) {
          case 0 :
              switch (match$2) {
                case 0 :
                    return 0;
                case 1 :
                    return -10;
                case 2 :
                    return -20;
                case 3 :
                    return -30;
                case 4 :
                    return -40;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 1 :
              switch (match$2) {
                case 0 :
                    return 10;
                case 1 :
                    return 0;
                case 2 :
                    return -10;
                case 3 :
                    return -20;
                case 4 :
                    return -30;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 2 :
              switch (match$2) {
                case 0 :
                    return 20;
                case 1 :
                    return 10;
                case 2 :
                    return 0;
                case 3 :
                    return -10;
                case 4 :
                    return -20;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 3 :
              switch (match$2) {
                case 0 :
                    return 30;
                case 1 :
                    return 20;
                case 2 :
                    return 10;
                case 3 :
                    return 0;
                case 4 :
                    return -10;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 4 :
              switch (match$2) {
                case 0 :
                    return 40;
                case 1 :
                    return 30;
                case 2 :
                    return 20;
                case 3 :
                    return 10;
                case 4 :
                    return 0;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          default:
            return Pervasives.failwith("will not reach this estimateValue case");
        }
    case 4 :
        var match$3 = count1Trues2(b);
        var match$4 = count2Trues2(b);
        switch (match$3) {
          case 0 :
              switch (match$4) {
                case 0 :
                    return 0;
                case 1 :
                    return -10;
                case 2 :
                    return -20;
                case 3 :
                    return -30;
                case 4 :
                    return -40;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 1 :
              switch (match$4) {
                case 0 :
                    return 10;
                case 1 :
                    return 0;
                case 2 :
                    return -10;
                case 3 :
                    return -20;
                case 4 :
                    return -30;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 2 :
              switch (match$4) {
                case 0 :
                    return 20;
                case 1 :
                    return 10;
                case 2 :
                    return 0;
                case 3 :
                    return -10;
                case 4 :
                    return -20;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 3 :
              switch (match$4) {
                case 0 :
                    return 30;
                case 1 :
                    return 20;
                case 2 :
                    return 10;
                case 3 :
                    return 0;
                case 4 :
                    return -10;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          case 4 :
              switch (match$4) {
                case 0 :
                    return 40;
                case 1 :
                    return 30;
                case 2 :
                    return 20;
                case 3 :
                    return 10;
                case 4 :
                    return 0;
                default:
                  return Pervasives.failwith("will not reach this estimateValue case");
              }
          default:
            return Pervasives.failwith("will not reach this estimateValue case");
        }
    default:
      var match$5 = count1Trues3(b);
      var match$6 = count2Trues3(b);
      switch (match$5) {
        case 0 :
            switch (match$6) {
              case 1 :
                  return -10000;
              case 2 :
                  return -20000;
              case 3 :
                  return -30000;
              case 4 :
                  return -40000;
              case 5 :
                  return -50000;
              case 6 :
                  return -60000;
              case 7 :
                  return -70000;
              case 8 :
                  return -80000;
              case 9 :
                  return -90000;
              case 10 :
                  return -100000;
              default:
                
            }
            break;
        case 1 :
            switch (match$6) {
              case 0 :
                  return 10000;
              case 1 :
                  break;
              case 2 :
                  return -10000;
              case 3 :
                  return -20000;
              case 4 :
                  return -30000;
              case 5 :
                  return -40000;
              case 6 :
                  return -50000;
              case 7 :
                  return -60000;
              case 8 :
                  return -70000;
              case 9 :
                  return -80000;
              case 10 :
                  return -90000;
              default:
                
            }
            break;
        case 2 :
            switch (match$6) {
              case 0 :
                  return 20000;
              case 1 :
                  return 10000;
              case 2 :
                  break;
              case 3 :
                  return -10000;
              case 4 :
                  return -20000;
              case 5 :
                  return -30000;
              case 6 :
                  return -40000;
              case 7 :
                  return -50000;
              case 8 :
                  return -60000;
              case 9 :
                  return -70000;
              case 10 :
                  return -80000;
              default:
                
            }
            break;
        case 3 :
            switch (match$6) {
              case 0 :
                  return 30000;
              case 1 :
                  return 20000;
              case 2 :
                  return 10000;
              case 3 :
                  break;
              case 4 :
                  return -10000;
              case 5 :
                  return -20000;
              case 6 :
                  return -30000;
              case 7 :
                  return -40000;
              case 8 :
                  return -50000;
              case 9 :
                  return -60000;
              case 10 :
                  return -70000;
              default:
                
            }
            break;
        case 4 :
            switch (match$6) {
              case 0 :
                  return 40000;
              case 1 :
                  return 30000;
              case 2 :
                  return 20000;
              case 3 :
                  return 10000;
              case 4 :
                  break;
              case 5 :
                  return -10000;
              case 6 :
                  return -20000;
              case 7 :
                  return -30000;
              case 8 :
                  return -40000;
              case 9 :
                  return -50000;
              case 10 :
                  return -60000;
              default:
                
            }
            break;
        case 5 :
            switch (match$6) {
              case 1 :
                  return 40000;
              case 2 :
                  return 30000;
              case 3 :
                  return 20000;
              case 4 :
                  return 10000;
              case 5 :
                  break;
              case 6 :
                  return -10000;
              case 7 :
                  return -20000;
              case 8 :
                  return -30000;
              case 9 :
                  return -40000;
              case 10 :
                  return -500000;
              default:
                
            }
            break;
        case 6 :
            switch (match$6) {
              case 0 :
                  return 60000;
              case 1 :
                  return 50000;
              case 2 :
                  return 40000;
              case 3 :
                  return 30000;
              case 4 :
                  return 20000;
              case 5 :
                  return 10000;
              case 6 :
                  break;
              case 7 :
                  return -10000;
              case 8 :
                  return -20000;
              case 9 :
                  return -30000;
              case 10 :
                  return -40000;
              default:
                
            }
            break;
        case 7 :
            switch (match$6) {
              case 0 :
                  return 70000;
              case 1 :
                  return 60000;
              case 2 :
                  return 50000;
              case 3 :
                  return 40000;
              case 4 :
                  return 30000;
              case 5 :
                  return 20000;
              case 6 :
                  return 10000;
              case 7 :
                  break;
              case 8 :
                  return -10000;
              case 9 :
                  return -20000;
              case 10 :
                  return -30000;
              default:
                
            }
            break;
        case 8 :
            switch (match$6) {
              case 0 :
                  return 80000;
              case 1 :
                  return 70000;
              case 2 :
                  return 60000;
              case 4 :
                  return 40000;
              case 5 :
                  return 30000;
              case 6 :
                  return 20000;
              case 7 :
                  return 10000;
              case 3 :
              case 8 :
                  break;
              case 9 :
                  return -10000;
              case 10 :
                  return -20000;
              default:
                
            }
            break;
        case 9 :
            switch (match$6) {
              case 0 :
                  return 90000;
              case 1 :
                  return 80000;
              case 2 :
                  return 70000;
              case 3 :
                  return 60000;
              case 4 :
                  return 50000;
              case 5 :
                  return 40000;
              case 6 :
                  return 30000;
              case 7 :
                  return 20000;
              case 8 :
                  return 10000;
              case 9 :
                  break;
              case 10 :
                  return -10000;
              default:
                
            }
            break;
        case 10 :
            switch (match$6) {
              case 0 :
                  return 100000;
              case 1 :
                  return 90000;
              case 2 :
                  return 80000;
              case 3 :
                  return 70000;
              case 4 :
                  return 60000;
              case 5 :
                  return 50000;
              case 6 :
                  return 40000;
              case 7 :
                  return 30000;
              case 8 :
                  return 20000;
              case 9 :
                  return 10000;
              default:
                
            }
            break;
        default:
          
      }
      var match$7 = count1Trues2(b);
      var match$8 = count2Trues2(b);
      switch (match$7) {
        case 0 :
            switch (match$8) {
              case 0 :
                  return 0;
              case 1 :
                  return -10;
              case 2 :
                  return -20;
              case 3 :
                  return -30;
              case 4 :
                  return -40;
              default:
                return Pervasives.failwith("will not reach this estimateValue case");
            }
        case 1 :
            switch (match$8) {
              case 0 :
                  return 10;
              case 1 :
                  return 0;
              case 2 :
                  return -10;
              case 3 :
                  return -20;
              case 4 :
                  return -30;
              default:
                return Pervasives.failwith("will not reach this estimateValue case");
            }
        case 2 :
            switch (match$8) {
              case 0 :
                  return 20;
              case 1 :
                  return 10;
              case 2 :
                  return 0;
              case 3 :
                  return -10;
              case 4 :
                  return -20;
              default:
                return Pervasives.failwith("will not reach this estimateValue case");
            }
        case 3 :
            switch (match$8) {
              case 0 :
                  return 30;
              case 1 :
                  return 20;
              case 2 :
                  return 10;
              case 3 :
                  return 0;
              case 4 :
                  return -10;
              default:
                return Pervasives.failwith("will not reach this estimateValue case");
            }
        case 4 :
            switch (match$8) {
              case 0 :
                  return 40;
              case 1 :
                  return 30;
              case 2 :
                  return 20;
              case 3 :
                  return 10;
              case 4 :
                  return 0;
              default:
                return Pervasives.failwith("will not reach this estimateValue case");
            }
        default:
          return Pervasives.failwith("will not reach this estimateValue case");
      }
  }
}

var Connect4 = {
  initialRows: 5,
  initialCols: 7,
  initialBoard: initialBoard,
  initialState: initialState,
  stringOfPlayer: stringOfPlayer,
  stringOfStatus: stringOfStatus,
  transpose: transpose,
  printListString: printListString,
  printBoardString: printBoardString,
  printBoard: printBoard,
  stringOfState: stringOfState,
  stringOfMove: stringOfMove,
  moveOfString: moveOfString,
  legalMoves: legalMoves,
  gameStatus: gameStatus,
  correctColumn: correctColumn,
  replacer: replacer,
  drop: drop,
  updateBoard: updateBoard,
  checkForZeroes: checkForZeroes,
  oppositePlayer: oppositePlayer,
  vertCount4: vertCount4,
  vertCount3: vertCount3,
  vertCount3Hole2: vertCount3Hole2,
  vertCount3Hole3: vertCount3Hole3,
  vertCount2: vertCount2,
  horzCount4: horzCount4,
  horzCount3: horzCount3,
  horzCount2: horzCount2,
  diag: diag,
  diagCount4Up: diagCount4Up,
  diagCount4Down: diagCount4Down,
  diagCount3Up: diagCount3Up,
  diagCount3Down: diagCount3Down,
  diagCount2Up: diagCount2Up,
  diagCount2Down: diagCount2Down,
  horzCount3Hole2: horzCount3Hole2,
  horzCount3Hole3: horzCount3Hole3,
  diagCount3UpHole2: diagCount3UpHole2,
  diagCount3DownHole2: diagCount3DownHole2,
  diagCount3UpHole3: diagCount3UpHole3,
  diagCount3DownHole3: diagCount3DownHole3,
  updateStatus: updateStatus,
  nextState: nextState,
  howManyPieces: howManyPieces,
  result2: result2,
  count1Trues2: count1Trues2,
  count2Trues2: count2Trues2,
  result3: result3,
  count1Trues3: count1Trues3,
  count2Trues3: count2Trues3,
  estimateValue: estimateValue
};

var MyGame = {
  stringOfPlayer: stringOfPlayer,
  stringOfState: stringOfState,
  stringOfMove: stringOfMove,
  initialState: initialState,
  legalMoves: legalMoves,
  gameStatus: gameStatus,
  nextState: nextState,
  moveOfString: moveOfString,
  estimateValue: estimateValue
};

exports.Connect4 = Connect4;
exports.MyGame = MyGame;
/* initialState Not a pure module */
